spi设备拥有有限的用户空间API，支持基础的半双工read()和write()来与SPI设备进行通信。通过使用ioctl()，全双工传输和设备I/O配置也是可用的。
```
#include <fcntl.h>
	#include <unistd.h>
	#include <sys/ioctl.h>
	#include <linux/types.h>
	#include <linux/spi/spidev.h>
```
你可能想要使用这些编程接口的原因包括：
- 在一个不容易崩溃的环境中进行程序设计；用户空间中的野指针通常不会导致任何Linux系统崩溃。
- 开发简单的协议用于与充当SPI从机的微控制器通信，你可能需要经常修改

当然，有些驱动程序永远不能在用户空间中编写，因为它们需要访问用户空间无法访问的内核接口（如IRQ处理程序或驱动程序堆栈的其他层）。

# 设备创建，驱动绑定
最简单的使用驱动的方法是:在设备的spi_board_info中把设备要使用的驱动列出来。"modalias"条目是 "spidev"，与暴露这个API的驱动名称相匹配。像往常一样配置设备的其他属性(每个字几个bit，SPI时钟，片选极性，等等)，这样之后就不用覆盖它们了。

（Sysfs还支持用户空间驱动的驱动程序绑定/解除驱动程序到设备的绑定/解除绑定。这种机制在将来可能会得到支持。）

当你这样做时，SPI设备的sysfs节点将包括一个带有"dev"属性的子设备节点。"dev"属性将被当做是udev或是mdev。(在大的系统中作为udev，在小的系统中作为mdev配置到busybox中，它的功能不那么丰富，但往往足够了)。对于一个在总线B上，片选为C的SPI设备，你会看到：
- /dev/spidevB.C

    字符特殊设备，主设备号153，次设备号动态分配。这是用户空间程序将打开的节点，由“udev”或“mdev”创建。

- /sys/devices/…/spiB.C

    和往常一样，SPI设备会作为其SPI主控制器的子设备。

- /sys/class/spidev/spidevB.C

    在驱动"spidev"绑定到设备时被创建。（目录或符号链接，取决于你是否启用了Kconfig选项"deprecated sysfs files"）

不要试图手动管理/dev字符设备特殊文件节点。这很容易出错，而且你需要仔细注意系统安全问题；udev/mdev应该已经被安全地配置好了。

如果你解除了对该设备的 "spidev "驱动的绑定，那么这两个“spidev”节点（在sysfs和/dev中）应该自动删除（分别由内核和udev/mdev删除）。您可以通过删除“spidev”驱动程序模块来解除绑定，这将影响使用此驱动程序的所有设备。你也可以通过让内核代码删除SPI设备来解除绑定，可能是通过删除SPI控制器的驱动（这样它的spi_master就消失了）。

由于这是一个标准的Linux设备驱动，它可以同时与任何数量的设备关联，尽管它只是碰巧向用户空间暴露了一个底层级的API。只要为每一个这样的SPI设备提供一个spi_board_info记录，就会为每个设备得到一个/dev设备节点。

# 基础字符设备API
对/dev/spidevB.D文件进行正常的open()和close()操作，就像你期望的那样。

标准的read()和write()操作显然只是半双工的，而且片选会在两次操作之间不会被激活。全双工访问和不需要片选失活的复合操作可以使用SPI_IOC_MESSAGE(N)进行请求。

一些ioctl()请求可以让你的驱动程序读取或覆盖设备当前的数据传输参数设置:

- SPI_IOC_RD_MODE, SPI_IOC_WR_MODE

    传递一个指向一个byte的指针，ioctl()就会返回(RD读)或是设置(WR写)SPI传输模式。使用SPI_MODE_0 ~ SPI_MODE_3；如果你愿意的话，你可以组合使用SPI_CPOL（时钟极性，空闲高电平）或SPI_CPHA（时钟相位，在下降沿采样）标志。请注意，该ioctl()请求仅适合单个字节的SPI模式标志。

- SPI_IOC_RD_MODE32, SPI_IOC_WR_MODE32

    传递一个指向一个uin32_t的指针，ioctl()就会返回(RD读)或是设置(WR写)完整的SPI传输模式，而不限于一个字节中的位

- SPI_IOC_RD_LSB_FIRST, SPI_IOC_WR_LSB_FIRST

    传递一个指向byte的指针，该指针将返回(RD)或设置(WR)用于传输SPI字的位对齐。0表示MSB优先，其他值表示不太常见的LSB优先编码。在这两种情况下，指定的值在每个字中右对齐，因此未使用的(TX)或未定义的(RX)位在MSBs

- SPI_IOC_RD_BITS_PER_WORD, SPI_IOC_WR_BITS_PER_WORD

    传递一个指向byte的指针，该指针将返回(RD)或设置(WR)每次SPI传输字中的bits数。值0表示8位。

-  SPI_IOC_RD_MAX_SPEED_HZ, SPI_IOC_WR_MAX_SPEED_HZ  

    传递一个指向u32的指针，该指针将返回(RD)或设置(WR)最大SPI传输速度。控制器不一定能够分配指定的时钟速率。

### 注意：
- 目前还不支持异步IO，一切都是纯同步的。
- 目前还没有办法报告用于将数据转移到特定设备的实际比特率。
- 从用户空间，你目前不能改变片选的极性。这可能会破坏对共享同一SPI总线的其他设备的传输。每个SPI设备在不使用时都会被取消选择，从而允许其他驱动程序与其他设备交互。
- 每个IO请求传输到SPI设备的字节数是有限制的。默认为一页，但可以通过模块参数来改变。
- 因为SPI没有底层的传输应答，所以当与一个不存在的设备交互时，通常不会看到任何IO错误。

# 全双工字符设备API
请参阅spidev_fdx.c示例程序，其中一个例子展示了全双工编程接口的使用。(尽管它并没有执行全双工传输)。该模型与内核spi_sync()请求使用的模型相同。各个传输提供了与内核驱动程序相同的功能(除了它不是异步的)。

这个例子显示了一个半双工RPC式的请求和响应消息。这些请求通常要求在请求和响应之间芯片不能被取消选择。几个这样的请求可以串联成一个内核请求，甚至允许芯片在每次响应后被取消选择。(其他protocol选项包括了改变每个传输段的字数和比特率）

要进行全双工请求，请为同一传输提供rx_buf和tx_buf。如果这两个缓冲区是同一个缓冲区，也是可以的