#GPIO Interfaces
此目录中的文档详细说明了如何访问驱动程序中的GPIOs，以及如何为提供GPIO的设备编写驱动。

因为内核中GPIO接口的历史，有两种不同的方式来获取和使用GPIO
+ 基于描述符的接口(descriptor-based interface)是控制GPIO的首选方式，该目录中的所有文件均对齐进行了描述。(除了gpio-legacy.txt)
+ 基于整数的接口(integer-based interface) 已经被弃用(但是因为兼容性原因仍然可以使用)，这种方式记录在文件gpio-legacy.txt

本文的剩余部分适用于descriptor-based interface。gpio-legacy.txt包含同样的内容，但是是适用于integer-based interface。

# What is GPIO
"通用输入/输出口"(GPIO)是一个灵活的由软件控制的数字信号。他们可由多种芯片提供,且对于从事嵌入式和定制硬件的 Linux 开发者来说是比较熟悉。每个GPIO 都代表一个连接到特定引脚或球栅阵列(BGA)封装中“球珠”的一个位。电路板原理图显示了 GPIO 与外部硬件的连接关系。驱动可以编写成通用代码，以使板级启动代码可传递引脚配置数据给驱动。

片上系统 (SOC) 处理器对 GPIO 有很大的依赖。在某些情况下,每个非专用引脚都可配置为 GPIO,且大多数芯片都最少有一些 GPIO。可编程逻辑器件(类似 FPGA) 可以方便地提供 GPIO。像电源管理和音频编解码器这样的多功能芯片经常留有一些这样的引脚来帮助那些引脚匮乏的 SOC。同时还有通过 I2C 或 SPI 串行总线连接的“GPIO扩展器”芯片。大多数 PC 的南桥有一些拥有 GPIO 能力的引脚 (只有BIOS固件才知道如何使用他们)。

GPIO 的实际功能因系统而异。通常用法有:
+ 输出值是可写的(高电平=1 低电平=0)。一些芯片提供如何驱动这个输出值的选项，例如只驱动一个值，支持"wire-OR"或是为其他值提供类似的方案(特别是开漏信号)。
+ 输入信号同样是可读的。一些芯片支持输出引脚的readback，这在“wire-OR”时非常有用(以支持双向信号)。有时GPIO控制器具有软件去输入毛刺/抖动的逻辑。
+ 输入经常可以用作IRQ信号。有时是边缘触发，有时是电平触发。这些IRQ信号可以作为系统唤醒事件，用于从低电量模式唤醒系统。
+ 通常GPIO会被配置成输入/输出,根据不同产品的需求，单向也存在。
+ 大多数GPIOs在持有自旋锁的时候可以访问，但是通过串行总线的则不能访问，有些系统支持这两种类型。

在给定的板上，每个GPIO都用于特定目的，例如监视MMC / SD卡的插入/拔出，检测卡的写保护状态，驱动LED，配置收发器，模拟串行总线，复位硬件看门狗，检测开关，依此类推。

# Common GPIO Properties
这些属性可以在其他的GPIO接口文档中看到，了解他们非常有用，特别是是在你需要定义GPIO映射时。

## Active-High and Active-Low
当GPIO输出信号"1"(高电平)的时候，很自然假设的GPIO是active的，而在输出"0"(低电平)的时候是inactive的。然而在实际中，GPIO的信号很可能在到达目标时就已经反转，或者设备对”active"的意义有不同的约定。这些决定对设备驱动来说应该是透明的，因此应该定义GPIO是高电平有效(active-high)还是低电平有效(active-low)，这样驱动只需要考虑逻辑信号，而不是GPIO上的电平信号。

## Open Drain and Open Source
有时共享的信号需要用到"开漏"(仅驱动低电平信号时)，或是“开源”(仅驱动高电平信号时)。该术语适用于CMOS晶体管:集电极开路用于TTL。上拉/下拉电阻会导致低电平/高电平信号。这有时会成为"wire-AND"。或是更实际地，从相反(low=ture)的角度看，这成为“wire-OR”。

一个普通的例子是：一个开漏信号是一个共享的低电平有效的IRQ信号。并且，有时双向数据总线信号会使用开漏信号。

一些GPIO控制器直接支持开漏或开源输出，但是大多数不支持。当你需要开漏信号，但是硬件不直接支持的时候，一个常用的方法是用任何即可作输入也可作输出的 GPIO
引脚来模拟。
```
    LOW: gpiod_direction_output(gpio, 0) ... 输出信号并且覆盖上拉配置
    HIGH: gpiod_direction_input(gpio) ... 关闭输出，因此上拉电阻会控制信号
```
相同的逻辑可以用来模拟开源信号，通过输出高电平，和将GPIO配置为输入以获得低电平。这些开漏/开源输出仿真可以通过GPIO框架透明地处理。

如果输出一个高信号，但是gpiod_get_value(gpio)却返回一个低值(在适当的上升时间后)，你就知道其他组件在共享信号线上输出了低电平。这是不一定是错误。一个常见例子是I2C时钟时如何被捕获的：一个slave需要一个相对慢的时钟，以延迟SCK的上升沿，而master也应该相应地地调整时钟。